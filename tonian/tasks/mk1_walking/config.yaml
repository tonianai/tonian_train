# Configuaration file for the walking task
# There are no universal "episodes" since every actor can terminate an episode prematurely
# This is the standard configuration for the walking env
# every value can be overwritten by the config in the constructor


name: 02_mk1_walking

physics_engine: physx

env: 
  num_envs: 1024
  env_spacing: 16
  max_episode_length: 1024 


  initial_velocities: 
    - 0
    - -1
    - 0

  randomize: False # if randomize true sample from the given distributions - if randomize false only take the mean

  randomizazion:
    start_pose:
      mean: [0,0,0,1]
      std: [0, 0.2, 0.2, 0]

    density:
      mean: 0.001
      std: 0.0001
    



  reward_weighting:
      death_height: 1.25 # the height of the base at which the episode is terminated and the actor is considered dead
      directional_factor: 0.8
      death_cost: 10
      energy_cost: 0.005
      alive_reward: 0.7
      upright_punishment_factor: 20 # higher values punish the actor more for bad posture
      jitter_cost: 0.25
      overextend_cost: 10

       
  agent:

      default_motor_power: 1000 

      motor_powers: # describe by using joint name and than the max efort in NM
        left_foot: 300
        left_knee: 1500
        left_hip_b: 1000
        left_hip_a: 1000
        
        right_foot: 300
        right_knee: 1500
        right_hip_b: 500
        right_hip_a: 500

        torso: 300

        left_elbow: 400
        left_arm_rotate: 200
        left_shoulder_b: 400
        left_shoulder_a: 400


        right_elbow: 400
        right_arm_rotate: 200
        right_shoulder_b: 400
        right_shoulder_a: 400


sim: # the sim can deal with domain randomizazion on the given variables
  dt: 0.0166 # 1/60 s
  substeps: 2
  up_axis: "z"
  use_gpu_pipeline: True
  gravity: [0.0, 0.0, -9.81]

task: 
  randomize: True
  randomization_params: 
    sim_params: 
      gravity:
        range: [0, 0.4]
        operation: "additive"
        distribution: "gaussian"
        schedule: "linear"  # "linear" will linearly interpolate between no rand and max rand
        schedule_steps: 3000
    actor_params:
      anymal:
        color: True
        rigid_body_properties:
          mass: 
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            setup_only: True # Property will only be randomized once before simulation is started. See Domain Randomization Documentation for more info.
            schedule: "linear"  # "linear" will linearly interpolate between no rand and max rand
            schedule_steps: 3000
        rigid_shape_properties:
          friction:
            num_buckets: 500
            range: [0.7, 1.3]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          restitution:
            range: [0., 0.7]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
        dof_properties:
          damping: 
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          stiffness: 
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          lower:
            range: [0, 0.01]
            operation: "additive"
            distribution: "gaussian"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          upper:
            range: [0, 0.01]
            operation: "additive"
            distribution: "gaussian"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000